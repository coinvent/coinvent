:-module(subst_inline,[inline_substitutions/1]).

% takes substitutions explicitly generated by the anti-unification process and 
% adds them into the attributes of the prolog variables that represent function symbols

inline_substitutions(s(F,I,E,P)):-
    inline_fixations(F),
    inline_insertions(I),
    inline_embeddings(E),
    inline_permutations(P).

inline_fixations([]).    
inline_fixations([f(Pname,Pname_new)|Rest]):-
    add_attr(Pname,subst_f,f(Pname_new)),
    %reverse_link allready prebuild when generated Pname
    inline_fixations(Rest).

inline_insertions([]).    
inline_insertions([i(Pname,Pname_new,PlaceOfArg,Insertion)|Rest]):-
    add_attr(Pname,subst_i,i(Pname_new,PlaceOfArg,Insertion)),
    length(Argsbefore,PlaceOfArg),
    append(Argsbefore,Argsafter,Argscurrent),
    append(Argsbefore,[_:Insertion],Argstemp),
    append(Argstemp,Argsafter,Argsold),
    put_attr(Pname_new,reverse_link,i_reverse(Pname,Argscurrent,Argsold)),
    inline_insertions(Rest).

inline_embeddings([]).
inline_embeddings([e(Pname,Pname_new,PlaceOfArg,EmbeddingPred,Arglength)|Rest]):-
    %dont need arglength for global substitutions because of unique name assumption
    add_attr(Pname,subst_e,e(Pname_new,PlaceOfArg,EmbeddingPred)),
    length(Argsbefore,PlaceOfArg),
    length(Argsembedded,Arglength),
    append(Argsbefore,Argsembedded,Argstemp),
    append(Argstemp,Argsafter,Argscurrent),
    append(Argsbefore,[_:(EmbeddingPred,Argsembedded)],Argstemp2),
    append(Argstemp2,Argsafter,Argsold),
    put_attr(Pname_new,reverse_link,e_reverse(Pname,Argscurrent,Argsold)),
    inline_embeddings(Rest).
    
inline_permutations([]).
inline_permutations([p(Pname,Pname_new,(Args,Args_subst))|Rest]):-
    add_attr(Pname,subst_p,p(Pname_new,(Args,Args_subst))),
    put_attr(Pname_new,reverse_link,p_reverse(Pname,Args_subst,Args)),
    inline_permutations(Rest).