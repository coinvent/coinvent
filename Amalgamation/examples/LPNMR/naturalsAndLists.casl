spec SemSys = 
  sort PriorityDummySort
  op prioDummyOp : PriorityDummySort
end

spec NatSuc = SemSys then
   sort Element
   sort Nat   
   op zero:Nat                    %% maps to nil  / null
   op s: Element * Nat -> Nat     %% maps to cons / constructor
   op sum: Nat -> Nat             %% maps to rev  / recfunc
   op qsum: Nat * Nat -> Nat      %% maps to qref / qrecfunc
   op canonical_element: Element  %%
   op plus : Nat * Nat -> Nat     %% maps to app
   
   forall x,y:Nat
       %% These axioms have a similar (but not necessarily equivalent) analogous partner axiom in spec List
       . sum(zero) = zero                                                         %(Ax-pluszerozero:p:2)% 
       . sum(s(canonical_element,x)) = plus(s(canonical_element,x),sum(x))        %(Ax-sumPlusRel:p:2)%  
       . qsum(s(canonical_element,x),y) = qsum(x,plus(s(canonical_element,x),y))  %(Ax-qsumplusRel:p:2)%  
       . qsum(zero,x) = x                                                         %(Ax-zeroQsumEqualX:p:2)% 
       . plus(zero,x) = x                                                         %(Ax-pluszerox:p:1)%  
       . plus(s(canonical_element,x),y) = s(canonical_element,plus(x,y))          %(Ax-plusSucc:p:1)%  
       . sum(x) = qsum(x,zero)                                                    %(Ax-sum-qsum:p:3)%   %% Known Theorem from Naturals
       . plus(sum(x), y) = qsum(x,y)                                              %(Ax-plus-qsum:p:3)%  %% This is the heureka lemma that we want to have in an analogous version for lists

    %% This is our dummy lemma to set priorities of operators, predicats and sorts
    . prioDummyOp = prioDummyOp %(Element:p:3--Nat:p:3--zero:p:3--s:p:3--sum:p:2--qsum:p:2--plus:p:1--canonical_element:p:2)%
end

spec List = SemSys then
  sort L
  sort El
     op nil : L                 %% maps to zero   / null
     op cons : El*L -> L        %% maps to s      / constructor
     op app : L * L -> L        %% maps to times  / auxfunc
     op rev : L -> L            %% maps to fact   / recfunc
     op qrev : L * L -> L       %% maps to qfact  / qrecfunc
     forall x,y: L, h : El
       . rev(nil) = nil                             %(Ax-RevNilXX:p:2)% 
       . rev(cons(h,x)) = app(rev(x),cons(h,nil))   %(ax-revconsEqAppRevCons:p:2)% 
       . qrev(nil,x) = x                            %(Ax-qrevnilxx:p:2)%
       . qrev(cons(h,x),y) = qrev(x,cons(h,y))      %(Ax-qrevconshxy:p:2)%       
       . app(nil,x) = x                             %(Ax-AppNilIsId:p:1)%        
       . app(cons(h,x),y) = cons(h,app(x,y))        %(Ax-AppConsHxyconshappxy:p:1)%        
       . rev(x) = qrev(x,nil)                       %(Ax-targetTheoremLists:p:3)% %% This is the target theorem of that we know it's correct for naturals, and that we want to "translate" to the theory of lists.       
       %% %% . app(rev(x),y) = qrev(x,y) %(Ax-heurekaLemmaLists:p:20)% %% This is the eureka lemma that we want to have for lists.

       %% This is our dummy lemma to set priorities of operators, predicats and sorts
     . prioDummyOp = prioDummyOp %(El:p:3--L:p:3--nil:p:3--cons:p:3--app:p:2--rev:p:2--qrev:p:2)%
end

