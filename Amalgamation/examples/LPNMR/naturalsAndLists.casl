spec SemSys = 
  sort PriorityDummySort
  op prioDummyOp : PriorityDummySort
end

%%% HERE WITH HAVE A VERSION OF NATURALS WITH FACT AS AN EXAMPLE FUNCTION
%%% THE SUCCESSOR FUNCTION IS DEFINED WITH DUPLICATE ARGUMENTS
%%% THIS IS SO THAT THE VIEW TO THE GENERIC SPACE CAN WORK
%%% SO INSTEAD OF S(X) WE WRITE S(X,X)


%% spec NatSuc_SumBlend = 
%%    sort Element
%%    sort Nat
%%    op canonical_element: Element
%%    op zero:Nat
%%    op s: Element * Nat -> Nat
%%    op plus : Nat * Nat -> Nat
%%    op sum : Nat -> Nat
%%    op qsum : Nat * Nat -> Nat
%%    forall x,y:Nat
%%    %%   . exists a: Nat . s(canonical_element,x) = a
%%    %%   . not (s(canonical_element,x) = zero)      %% remove this in GEN
%%    %%    . fact(zero) = s(canonical_element,zero)  %% remove this in GEN
%%    %%    . fact(s(canonical_element,x)) = times(s(canonical_element,x),fact(x))  %% remove this in GEN
%%    %%    . qfact(s(canonical_element,x),y) = times(qfact(x,s(canonical_element,x)),y) %% remove this in GEN
%%       . qfact(zero,x) = x 
   
%%       . plus(zero,x) = x
%%       . plus(s(canonical_element,x),y) = s(canonical_element,plus(x,y))
%%    %%    . times(zero,y) = zero  %remove this in gen
%%    %%    . times(s(canonical_element,x),y) = plus(y,times(x,y)) %remove this in gen

%%    %%    . times(fact(x),y) = qfact(x,y)  %This is the Eureka lemma that we want to obtain by blending
%%    %%    . fact(x) = qfact(x,zero)    %implied %% This is the theorem that we want to prove using the Eureka lemma
%% end


spec NatSuc = SemSys then
   sort Element
   sort Nat   
   op zero:Nat                    %% maps to nil
   op s: Element * Nat -> Nat     %% maps to cons
   op times : Nat * Nat -> Nat    %% maps to app
   op fact: Nat -> Nat            %% maps to rev
   op qfact: Nat * Nat -> Nat     %% maps to qref
   op canonical_element: Element  %% maps to h
   
   op plus : Nat * Nat -> Nat     %% remove
   
   forall x,y:Nat
       %% These axioms have a similar (but not necessarily equivalent) analogous partner axiom in spec List
       %% . times(zero,y) = zero                                                                                     %% remove
       . qfact(zero,x) = x 
       %% . plus(s(canonical_element,x),y) = s(canonical_element,plus(x,y))                                          %% remove
       %% . fact(zero) = s(canonical_element,zero)                                                                   %% remove
       %% . fact(s(canonical_element,x)) = times(fact(x),s(canonical_element,x))  %(Ax_multiplyNumberWithFactorial)% %% remove
       %% . qfact(s(canonical_element,x),y) = times(qfact(x,s(canonical_element,x)),y)                               %% remove
       . not (s(canonical_element,x) = zero) %(Ax_succNotZero)%
       %% The following axioms have no similar analogous partner in spec List 
       %% . plus(zero,x) = x                                                                                         %% remove
       %% . times(s(canonical_element,x),y) = plus(y,times(x,y))                                                     %% remove

   %%    . times(fact(x),y) = qfact(x,y)  %% This is the Eureka lemma that we want to obtain by blending
       . fact(x) = qfact(x,zero)          %(targetTheorem_Nat:p:1)% %% This is the target theorem that we want to prove using the Eureka lemma

      %%   . exists a: Nat . s(canonical_element,x) = a %% This should not be in the theory at all, because s is a total function, which implies this axioms.

    %% This is our dummy lemma to set priorities of operators, predicats and sorts
    %% . prioDummyOp = prioDummyOp %(Element:p:17--Nat:p:16--zero:p:15--s:p:14--times:p:13--fact:p:12--qfact:p:11--canonical_element:p:10)%
end




%%% 
spec List = SemSys then
  sort L
  sort El
  sort Value
     op nil : L                 %% maps to zero
     op cons : El*L -> L        %% maps to s
     op app : L * L -> L        %% maps to times
     op rev : L -> L            %% maps to fact
     op qrev : L * L -> L       %% maps to qfact
     op h : El                  %% maps to canonical_element
     %% op valueOf : El -> Value   %% remove
     forall x,y: L
       %% . app(nil,x) = x                            %% remove
       . qrev(nil,x) = x   
       %% . app(cons(h,x),y) = cons(h,app(x,y))       %% remove
       %% . rev(nil) = nil                            %% remove
       %% . rev(cons(h,x)) = app(rev(x),cons(h,nil))  %% remove -- This is similar to axiom (Ax_multiplyNumberWithFactorial), but can not be mapped because it contains nil in the last element of its rhs, not x       
       %% . qrev(cons(h,x),y) = qrev(x,cons(h,y))     %% remove
       . not (cons(h,x) = nil) %(Ax_consNotNil)%

       . app(rev(x),y) = qrev(x,y) %% This is the eureka lemma that we know is correct for Lists, and that we want to "translate" to the theory of naturals.
       . rev(x) = qrev(x,nil)      %% This is the target theorem of that we know it's correct for lists, and that we want to "translate" to the theory of natural numbers.

       %% This is our dummy lemma to set priorities of operators, predicats and sorts
     %% . prioDummyOp = prioDummyOp %(El:p:17--L:p:16--nil:p:15--cons:p:14--app:p:13--rev:p:12--qrev:p:11--h:p:10)%
end


%%% HERE IS A WEAKENED VERSION WITH SOME AXIOMS REMOVED
%% spec GenNatSuc = 
%%    sort Nat
%%    sort Element
%%    op canonical_element: Element
%%    op zero:Nat
%%    op s: Element * Nat -> Nat
%%    op fact: Nat -> Nat
%%    op qfact: Nat * Nat -> Nat
%%    op plus: Nat * Nat -> Nat
%%    op times : Nat * Nat -> Nat
%%    forall x,y:Nat    
%%       . qfact(zero,x) = x 
%%       . fact(x) = qfact(x,zero)    %implied
%%       . times(fact(x),y) = qfact(x,y)  %lemma required to prove this
%%       . times(zero,y) = zero
%% end


%%% NOW WE CREATE A GENERIC SPACE WITH NULL ELEMENT
%%% CONSTRUCTOR ELEMENT
%%% RECURSIVE FUNCTION
%%% TAIL_RECURSIVE FUNCTION
%%% AUXILIARY FUNCTION

%% spec Gen =
%%   sorts H,G
%%   op null:G
%%   op constructor: H * G -> G
%%   op recfunc: G -> G
%%   op qrecfunc: G * G -> G
%%   op auxfunc: G * G -> G
%% end

%% view I1 : Gen to NatSuc = 
%%    H |-> Element,
%%    G |-> Nat,
%%    null |-> zero,
%%    constructor |-> s,
%%    recfunc |-> fact,
%%    qrecfunc |-> qfact,
%%    auxfunc |-> times

%% view I2 : Gen to List = 
%%    H |-> El,
%%    G |-> L,
%%    null |-> nil,
%%    constructor |-> cons,
%%    recfunc |-> rev,
%%    qrecfunc |-> qrev,
%%    auxfunc |-> app

%% view I3 : Gen to GenNatSuc = 
%%    H |-> Element,
%%    G |-> Nat,
%%    null |-> zero,
%%    constructor |-> s,
%%    recfunc |-> fact,
%%    qrecfunc |-> qfact,
%%    auxfunc |-> times

%% %% THIS IS IMMEDIATELY INCONSISTENT
%% spec colimit = combine I1,I2
%%   with 
%%        s |-> cons,
%%        zero |-> nil

%% spec colimit_consistent = combine I2, I3 
%%    with 
%%        s |-> cons,
%%        zero |-> nil