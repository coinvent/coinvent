logic CASL

%%%% This is just a standard notion of field

spec Field =
     sort Real
     preds 
          __ >= __, __ > __: Real * Real;

	  ops
	  __ + __:Real * Real -> Real;
	  __ * __:Real * Real -> Real;
	  - __: Real -> Real;
	  ti __: Real -> Real;
     	  0:Real;
	  1:Real;
	  sqrt __: Real ->? Real;
	  sq __: Real -> Real

		     
     forall x,y,z,v:Real
     	    . x+0=x			
     	    . x+y=y+x
	    . x+(y+z) = (x+y)+z
	    . x + (-x) = 0
	    . ((not (x=0)) /\ (not (y=0))) => x*y = y*x
	    . ((not (x=0)) /\ (not (y=0)) /\ (not (z=0))) => (x*y)*z=x*(y*z)
	    . (not (x=0)) => x*(ti x) = 1 
	    . ((not (x=0)) /\ (not (y=0)) /\ (not (z=0))) => x*(y+z) = (x*y)+(x*z)
	    . ((x >=y) /\ (z >= v)) => (x+z) >= (y+v)
	    . (x>0) /\ (y>0) => (x*y)>0
 end
				    
	     	   

%%%% This is a vector space with a norm

spec VectorSpace = 
     sort Real
     free type Vec ::= pair(real:Real;complex:Real)
     preds 
          __ >= __, __ > __: Real * Real;

	   ops
	   __ + __:Real * Real -> Real;
	   __ * __:Real * Real -> Real;
	  - __: Real -> Real;
	  ti __: Real -> Real;
     	  0:Real;
	  1:Real;
	  field_norm __:Real -> Real;
	  __ vpl __:Vec * Vec -> Vec;
	  __ vti __:Real * Vec -> Vec;
	  vmi __:Vec -> Vec;
	  vec_norm __:Vec->Real;
	  vzero:Vec
	  %%% introducing 2-d vectors
	  basis_real:Vec;
	  basis_complex:Vec;
	  sqrt __: Real ->? Real;
	  sq __: Real -> Real


 forall x,y,z,v:Real;
	a,b,c,d:Vec
     	    . x+0=x			
     	    . x+y=y+x
	    . x+(y+z) = (x+y)+z
	    . x + (-x) = 0
	    . ((not (x=0)) /\ (not (y=0))) => x*y = y*x
	    . ((not (x=0)) /\ (not (y=0)) /\ (not (z=0))) => (x*y)*z=x*(y*z)
	    . (not (x=0)) => x*(ti x) = 1 
	    . ((not (x=0)) /\ (not (y=0)) /\ (not (z=0))) => x*(y+z) = (x*y)+(x*z)
	    . ((x >=y) /\ (z >= v)) => (x+z) >= (y+v)
	    . (x>0) /\ (y>0) => (x*y)>0
	    . (a vpl vzero) = a
	    . (a vpl b) = (b vpl a)
	    . (a vpl (c vpl d)) = ((a vpl c) vpl d)
	    . (a vpl (vmi a)) = vzero
	    . (x vti (a vpl b)) = (x vti a) vpl (x vti b)
	    . ((x+y) vti a) = (x vti a) vpl (y vti a)
	    . (x vti (y vti a)) = (x * y) vti a
	    . (1 vti a) = a
	    . (vec_norm a) >= 0
	    . (vec_norm a >= 0 <=> (not (a = vzero)))
	    . (vec_norm (x vti a)) = (field_norm x)*(vec_norm a)
	    . (vec_norm (a vpl b)) = (vec_norm a) + (vec_norm b)
	      %%% forcing linear independence
	    . (((x vti basis_real) vpl (y vti basis_complex)) = vzero) <=> (x = 0) /\ (y = 0)
	    . (exists s,t:Real. a = ((s vti basis_real) vpl (t vti basis_complex)))
end

spec Gen = 
     sort Generic
     ops
     __ plus __:Generic * Generic -> Generic;
     zero:Generic;
     minus __:Generic -> Generic
	   
	forall x,y:Generic
     	       . x plus  zero=x			
     	       . x plus y=y plus x
	       . x plus (minus x) = zero
end


view I1: Gen to Field = 
		__ plus __ |-> __ + __, zero |-> 0, minus __ |-> - __

view I2: Gen to VectorSpace = 
	       __ plus __ |-> __ vpl __,zero |-> vzero, minus __ |-> vmi __


spec Colimit =
  combine I1,I2  with gn_n2 |-> gt,gn_n4 |-> gte
end


spec Complex_Field = 
     sort Real
     free type Complex ::= pair(real:Real,complex:Real)
     preds 
	   __ >= __, __ > __:Real * Real;
	   __ gte __, __ gt __: Complex * Complex;
     ops
     __ + __: Real * Real -> Real;
     __ * __: Real * Real -> Real;
     - __: Real -> Real;
     ti __: Real -> Real;
     0: Real;
     1: Real;
     field_norm __:Real -> Real;
     __ cpl __:Complex * Complex -> Complex;
     __ cti __:Real * Complex -> Complex;
     cmi __:Complex -> Complex;
     complex_norm __:Complex -> Real;
     complex_zero:Complex;
     %%% introducing 2-d vectors
     basis_real:Complex;
     basis_complex:Complex;
     __ prod __: Complex * Complex -> Complex;
     times_inv __: Complex -> Complex;
     norm __: Complex -> Real;
     sqrt __: Real ->? Real;
     sq __: Real -> Real;
     csq __: Complex -> Complex;
     csqrt __: Complex ->? Complex

     forall x,y,z,v:Real;
	    a,b,c,d:Complex
	    . x+0=x			
     	    . x+y=y+x
	    . x+(y+z) = (x+y)+z
	    . x + (-x) = 0
	    . ((not (x=0)) /\ (not (y=0))) => x*y = y*x
	    . ((not (x=0)) /\ (not (y=0)) /\ (not (z=0))) => (x*y)*z=x*(y*z)
	    . (not (x=0)) => x*(ti x) = 1 
	    . ((not (x=0)) /\ (not (y=0)) /\ (not (z=0))) => x*(y+z) = (x*y)+(x*z)
	    . ((x >= y) /\ (z >= v)) => (x+z) >= (y+v)
	    . (x>0) /\ (y>0) => (x*y)>0
	    . (a cpl complex_zero) = a
	    . (a cpl b) = (b cpl a)
	    . (a cpl (c cpl d)) = ((a cpl c) cpl d)
	    . (a cpl (cmi a)) = complex_zero
	    . (x cti (a cpl b)) = (x cti a) cpl (x cti b)
	    . ((x+y) cti a) = (x cti a) cpl (y cti a)
	    . (x cti (y cti a)) = (x * y) cti a
	    . basis_real = pair(1,0)
	    . basis_complex = pair(0,1)
	    . (pair (x,y)) cpl (pair (z,v)) = (pair((x+z),(y+v)))
	    . (pair(x,y) prod pair(z,v)) = pair(((x*z)+(-(y*v))),((x*v)+(y*z)))
	    . times_inv (pair(x,y)) = (ti (sq (norm (pair(x,y))))) cti (pair(x,(- y)))
	    . norm (pair(x,y)) = sqrt((x*x) + (y*y)) 
end

view I3: Colimit to Complex_Field =
     Generic |-> Complex,
     Real |-> Real,
     1 |-> basis_real,
     zero |-> complex_zero,
     gte:Real |-> 1,
     __ * __ |-> __ prod __,
     __ + __ |->  __ + __,
     __ vpl __ |-> __ cpl __,
     __ vti __ |-> __ cti __,
     basis_complex |-> basis_complex,
     basis_real |-> basis_real,
     ti __ |-> times_inv __,
     vec_norm __ |-> norm __,
     vmi __ |-> cmi __,
    gn_n6 : Real * Real -> Real |->  __ * __,
    gn_ti22 __: Real -> Real |-> ti __,
     __ > __ |-> __ gt __,
    __ >= __ |-> __ gte __,
    gt: Real * Real |-> __ > __,
    gte:Real * Real |-> __ >= __,
    gn_sq18 __: Real -> Real |-> sq __,
    gn_sqrt20 __: Real -> Real |-> sqrt __,
    sq __ |-> csq __,
    sqrt __ |-> csqrt __

			  
