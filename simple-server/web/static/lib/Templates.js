/* file: Templates.js
Depends on: underscore, jQuery

WARNING: Templates in separate files can be sensitive to race conditions on when the different
template files are loaded. Templates in one file should therefore never refer to templates from
another file, unless the caller explicitly manages loading, e.g. by using $.when().

## Mods to Underscore

We use underscore.js templates, but with a couple of tweaks:

 - You can load templates from html files :) This is a big win for editing.

 - The input value (e.g. a SoDash data object) is always available as the
 variable "context". Context is always set (even if there is no input value),
 and always has a circular reference context.context = context.
This (a) lets us to handle missing fields without undefined errors (you can safely and easily test context.property),
and (b) lets us pass the item on to nested template calls.

 - Embedded javascript is via <script>...</script>, instead of <% ... %>
 (interpolation is unchanged as <%= %>).
 Important: We're using a simple regex which only matches exactly on "<script>"
 This enables syntax highlighting in the editor.
 Side effects: be careful if using templates to insert "static"
 script blocks (but that's probably a bad idea anyway).

## Usage

Define your templates in an html file.
Write html like this in a separate file, e.g. MyTemplates.html:

	<template id='MyWidgetName' data-bind="context">
		<div class='MyWidgetName'>etc</div>
	</template>

The id is required. The data-bind is optional (see data-binding and MiniModelView below).

Load it via: `loadTemplates(url)`   
Or you can create templates programatically via: `parseTemplate(name, html)`

Use it via: `templates.MyWidgetName(item)`

There is ajaxify support for finding & filling in template calls from html of the form:

	<div class="FromTemplate" template="MyTemplateName" templateSrc="MyUrlForTemplateHtml"></div>

templateSrc is optional. If set, MyUrlForTemplateHtml will be loaded via loadTemplates()
*/
(function () {
	
	// Adjust Underscore.js templating
	// Use script tags for embedded JavaScript.
	_.templateSettings = {
	  interpolate: /<%=([\s\S]+?)%>/g,
	  evaluate: /<script>([\s\S]+?)<\/script>/g
	};

	/** A custom error for issues within templates. */
	function TemplateError(name, error) {
		this.message = "Error while parsing '" + name + "' (" + error.toString () + ")";
	}
	TemplateError.prototype = new Error();
	TemplateError.prototype.name = "TemplateError";
	/**
	 * Delegate to reportError, or console
	 */
	function _reportError(error) {
		if (reportError) reportError(error);
		else console.error(error);
	}

	/** Map of template file urls to the deferred returned by the request for that
		template. Ensures that each template file is only requested once. */
	var loadedTemplates = {};

	/** Compiled templates are stored here, so as not to pollute the global namespace. */
	window.templates = {};

	// Placeholder for storing functions that should be called by templates,
	// so they don't need to pollute the global namespace.
	// TODO What is best-practice for defining such functions??
	window.templates.fn = {};

	/**
	 * Poke a SoDash item so it can serve as an underscore template context.
	 * This lets context.property be used for potentially undefined properties.
	 * This is called automatically for templates loaded via loadTemplates().
	 * @param item Can be null
	 * @returns item (modified) Never null
	 * It is harmless to call this multiple times
	**/
	var _templateContext = function (item) {
		if (!item) {
			item = {};
		}

		item.context = item;

		/** @deprecated You can do the same with `(x.f=y) && x` 
		 * Set (or reset) a property (Warning: modifies obj!) & return the obj
		// obj can be null, in which case a new object is created.
		// Typical use case: <%= templates.subTemplate(set(context.child, key, value)); %> */
		item.set = function (obj, key, value) {
			if (!obj) {
				obj = {};
			}

			obj[key] = value;

			return obj;
		};

		return item;
	};

	/** 
	* @param html {string}
	* @param id {string}
	* @returns {string} html with the parent element having the given id
	*/
	function _setId(html, id) {
		// Use jQuery to insert the ID (a little wasteful but safe - we could just string insert instead)
		var $html = $(html);
		// either one element, or none
		assert($html.length < 2, "Templates.js - _setId: $html length > 1");
		$html.attr('id', id);
		html = $("<div></div>").append($html).html();
		return html;
	}

	/**
	 * Creates the function used to render a template. The function generated by
	 * `_.template` is wrapped so that the returned function always provides the
	 * template context in the `context` variable. Error reporting is also added,
	 * so that templates which fail to render are reported to the server.
	 *
	 * @param {String} contents - The contents of the template.
	 * @param {?String} name - The name of the template, used to report errors when
	 * attempting to render the template.
	 * @returns {Function} The customised template rendering function. 
	 * This is a function (context, ?params) -to- html.
	 * 
	**/
	var parseTemplate2 = function (contents, name, dataBind) {
		try {
			var tFn = _.template(contents);
			// add data + params -> context
			var tFn2 = function(data, params) {
				try {
					if (params) {
						// Params take precedence over context-data
						data = _.extend({}, data, params);
					}
					// turn data (which may be unset) into a context
					var context = _templateContext(data);					
					// The underlying underscore template function
					var html = tFn(context);
					return html;
				} catch (err) {
					// The error caught while processing templates is not informative, so let's create one that is.
					_reportError(new TemplateError(name, err));
				}
			};
			if ( ! dataBind) return tFn2;
			assert(dataBind==='context' || dataBind===true, "Templates.js - parseTemplate2: databind !== context or !== true");
			// setup model-view binding
			var tFn3 = function(data, params) {
				// turn data (which may be unset) into a context
				var context = _templateContext(data);
				// The core template function
				var html = tFn2(context, params);
				// set a unique id
				var genId = _.uniqueId('_tmplt');
				html = _setId(html, genId);
				// update fn
				var updateFn = function() {
					var $elem = $('#'+genId);
					if ($elem.length==0) {
						// the element was removed
						return; // TODO splice this function out from _updateViewFns??
					}
					var freshHtml = tFn2(context, params);
					freshHtml = _setId(freshHtml, genId);
					$elem.replaceWith(freshHtml);
				};
				if ( ! context._updateViewFns) context._updateViewFns = [];
				context._updateViewFns.push(updateFn);
				if ( ! context.updateViews) context.updateViews = function() {
					for(var fi=0; fi<this._updateViewFns.length; fi++) {
						this._updateViewFns[fi]();
					}
				}.bind(context);
				return html;
			};
			return tFn3;
		} catch (err) {
			// The error caught while parsing templates is not informative, so let's create one that is.
			_reportError(new TemplateError(name, err));
		}
	}; // ./parseTemplate2

	/**
	 * Obtains the url to load templates from. If there are compiled templates being
	 * used, that url will be returned.
	 *
	 * @param {String} originalUrl - The url to return if there is no compiled
	 * templates url available.
	 * @returns {String} The url from which to load the templates.
	**/
	var getTemplatesUrl = (function () {
		var hasAccessedDOM = false, // Only access the DOM once, and cache the result.
			fileUrl = null; // The retrieved url.

		// This is the function that is invoked when `getTemplatesUrl` is invoked.
		return function (originalUrl) {
			if (hasAccessedDOM) {
				if (fileUrl === null) {
					return originalUrl;
				} else {
					return fileUrl;
				};
			}

			// Only access the DOM once.
			hasAccessedDOM = true;

			fileUrl = getUrlFromDOM();

			// Call this function again to make use of the relevant url.
			return getTemplatesUrl(originalUrl);
		}

		// Tries to obtain the compiled templates url from the DOM. Checks the
		// 'html' element for the attribute 'data-compiled-templates', and if
		// found uses the url it contains.
		function getUrlFromDOM() {
			var htmlElement = document.getElementsByTagName('html'),
				i;

			// Try to obtain the lanaguage from the `data-compiled-templates` attribute on the html element.
			for (i = 0; i < htmlElement.length; i++) {
				urlFromDOM = htmlElement[i].getAttribute('data-compiled-templates');

				if (urlFromDOM) {
					return urlFromDOM;
				}
			}

			return null;
		}
	}());

	/**
	 * Use this to load-then-process templates.
	 *
	 * @param {String} url The url from which the templates should be loaded.
	 * The load request is cached, so repeated calls will only load the templates once.
	 * @param {Function} [callback] The callback function to execute once the
	 * templates have been loaded.
	 * @param forceLoad {?boolean} If true, ignore Creole.useCompiledTemplates.
	 * @returns A jQuery deferred object.
	 * It is resolved when the templates have been loaded and parsed.
	**/
	window.loadTemplates = function (url, callback, forceLoad) {
		var templateRequest; // The deferred returned by the request for this template.

		// HACK: Check if we are using compiled templates, and update the url if so.
		// TODO use a settable "url router" instead to decouple from Creole
		if (window.Creole && Creole.useCompiledTemplates && ! forceLoad) {
			url = getTemplatesUrl(url);
		}

		console.log("templates","Loading from "+url+"...");

		if (loadedTemplates[url]) {
			// Use the previously cached request for this template.
			templateRequest = loadedTemplates[url];

			console.log('Templates already requested from file url(' + url + '). Adding callback.');
		} else {
			// Create a new request for the templates at the supplied url.
			templateRequest = createTemplateRequest(url, callback);

			// Cache the request for this url.
			loadedTemplates[url] = templateRequest;
		}

		// If a callback was supplied, invoke it upon resolution of the request.
		if (typeof callback === 'function') {
			templateRequest.done(function () {
				$(callback); // Don't invoke until the DOM is ready.
			});
		}

		// ajaxifyFromTemplate on load
		templateRequest.done(function (parsedTemplates) {
			var templateName;
			for (templateName in parsedTemplates) {
				if (parsedTemplates.hasOwnProperty(templateName)) {
					$(function () {
						ajaxifyFromTemplate(parsedTemplates[templateName], templateName);
					});
				}
			}
		});

		console.log('Template request', url, templateRequest);
		return templateRequest;
	};

	/**
	 * Creates an AJAX request to load templates from the supplied url. If a callback
	 * is supplied, it is invoked when the request is successfully resolved.
	 *
	 * @param {String} url - The url from which the templates should be loaded.
	 * @param {Function} callback - Callback that should be invoked on success.
	 * @returns A jquery deferred object, resolved once the templates have been loaded and parsed.
	**/
	function createTemplateRequest(url, callback) {
		// This will be resolved when the templates are loaded and parsed.
		var deferred = $.Deferred();
		var ajaxCall = $.ajax({
			url: url,
			dataType:'html'
		}).then(function (result) {		
			assert(result, 'Templates.js - createTemplateRequest: No content found in templates file at [' + url + ']');
			var parsedTemplates = parseTemplates(result);
			console.log("templates","...Loaded from " + url, parsedTemplates);
			// done
			deferred.resolve(parsedTemplates);		
		}).fail(function(err) {
			console.error("Template request fail", url);
		});	
		return deferred;
	}



	/** 1=id, 3=data-bind, 4=contents */
	var templateMatcher = /<template\s+id=['"](.+?)['"]\s*(data-bind=['"](.+?)['"])?>([\s\S]*?)<\/template>/gm;

	/**
	 * Extracts template functions from a file of html templates. The RegExp
	 * `templateMatcher` has two capturing groups: the first is the name of the
	 * template, and the second is the html contents of the template.
	 *
	 * @param {String} templatesHtml - The html for one or more templates.
	 * @returns {Object} A map of the extracted templates, by name.
	**/
	window.parseTemplates = function (templatesHtml) {
		assert(templatesHtml !== undefined, "Templates.js - parseTemplates: no html"); // "" is allowed
//		console.log("parseTemplates");
		var matchedTemplate,
			parsedTemplates = {};

		// Strip whitespace (but not spaces) from between closing and opening tags.
		// 2014 - jonathan - Added carriage returns too, IDEs can be unfaithful
		templatesHtml = templatesHtml.replace(/>[\t\n\r]*</g, '><');

		// Match the html of templates in the supplied file, and return
		while ((matchedTemplate = templateMatcher.exec(templatesHtml))) {
			var tid = matchedTemplate[1];
			var dataBind = matchedTemplate[3];
			var thtml = matchedTemplate[4];
			assert(tid && (thtml!==undefined), "Templates.js - parseTemplates: Missing id or html from: "+tid);
			parsedTemplates[tid] = parseTemplate(tid, thtml, dataBind);
		}

		return parsedTemplates;
	}

/**
 * Parses the id and html content of a template, generating a global template
 * function for that template.
 *
 * @param {String} templateId - The id of this template.
 * @param {String} templateHtml - The html content of this template. Does NOT include the wrapping template tag.
 * @param {?String} dataBind - Optional, set as "context" to bind a MiniModelView to the context object.
 * @returns {Function} The invokable form of this template.
**/
	window.parseTemplate = function(templateId, templateHtml, dataBind) {
		// NB: "" for the templateHtml is allowed
		assert(templateId && (templateHtml!==undefined), "Templates.js - parseTemplate: Missing id or html");
//		console.log("parseTemplate", templateId, dataBind);
		assert(templateId, 'Templates.js - parseTemplate: Template has no name');

		// assert(templateHtml, 'Template [' + templateId + '] has no content');
		// Trim any whitespace
		templateHtml = templateHtml.trim();
		templateFunction = parseTemplate2(templateHtml, templateId, dataBind);

		if (window.templates[templateId]) {
			console.warn('Overwriting template [' + templateId + ']');
		}

		window.templates[templateId] = templateFunction;

		return templateFunction;
	}

	/** Check each template for un-ajaxed divs.
	Handles ajax loading of FromTemplate divs. */
	window.ajaxifyFromTemplates = function () {
		// Load some?
		var elems = $('div.FromTemplate').not(".ajaxed");
		elems.each(function() {
			var elem = $(this);
			var src = elem.attr('templateSrc');
			if (src) {
				loadTemplates(src);
			}
		});
		// Apply loaded templates to un-ajaxed divs
		for(var tName in templates) {
			var template = templates[tName];
			ajaxifyFromTemplate(template, tName);
		}

		$(document).trigger("FromTemplates:done");
	}

	/**
	 * @param template {function}
	 * @param tName {string}
	 */
	function ajaxifyFromTemplate(template, tName) {
		assert(template || tName, " Templates.js - ajaxifyFromTemplate: template || tName undefined");
		// Get elements using this template which are not ajaxed
		// This is where the "FromTemplate" divs get expanded
		var elems = $('[template="' + tName + '"]').not(".ajaxed");

		elems.each(function() {
			var elem = $(this);
			//console.log("templates","...Applying "+tName, elem);
			var cntxt = {};
			var tContext = elem.attr('context');
			if (tContext) {
				try {
					cntxt = JSON.parse(tContext);
				} catch (e) {
					_reportError(new Error('Unable to parse context JSON for template "' + tName + '" (' + e.toString() + ')'));
					return;
				}
			}

			var h = template(cntxt);

			elem.html(h);

			elem.addClass('ajaxed');
		});
	}

	// SoDash cruft: apply to late-loading html
	if (window.ajaxifyFunctions) {
		console.log("registering ajaxify templates...");
		ajaxifyFunctions.push(ajaxifyFromTemplates);
	}

	$(ajaxifyFromTemplates);

	// setup a simple logging template -- it spits the context into the html as a comment
	// E.g. usage: <%=templates.log(context)%>
	// NB: Why not JSON.stringify? because we may have circular data structures.
	parseTemplates("<template id='log'><script>print('<!-- '+(printer? printer.str(context, [], 1).replace(/(<!--|-->)/g,''): '')+'-->');</script></template>");
}());
