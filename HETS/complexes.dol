logic CASL

%%%% This is just a standard notion of field

spec Field =
     sort Real
     preds 
          __ >= __, __ > __: Real * Real;

	  ops
	  __ + __:Real * Real -> Real;
	  __ * __:Real * Real -> Real;
	  - __: Real -> Real;
	  ti __: Real -> Real;
     	  0:Real;
	  1:Real
		     
     forall x,y,z,v:Real
	    . (exists t:Real.(x+y)=t)
     	    . x+0=x			
     	    . x+y=y+x
	    . x+(y+z) = (x+y)+z
	    . x + (-x) = 0
	    . ((not (x=0)) /\ (not (y=0))) => (exists t:Real.x*y=t)
	    . ((not (x=0)) /\ (not (y=0))) => x*y = y*x
	    . ((not (x=0)) /\ (not (y=0)) /\ (not (z=0))) => (x*y)*z=x*(y*z)
	    . (not (x=0)) => x*(ti x) = 1 
	    . ((not (x=0)) /\ (not (y=0)) /\ (not (z=0))) => x*(y+z) = (x*y)+(x*z)
	    . ((x >=y) /\ (z >= v)) => (x+z) >= (y+v)
	    . (x>0) /\ (y>0) => (x*y)>0
 end
				    
	     	   

%%%% This is a vector space with a norm

spec VectorSpace = 
     sort Real
     free type Vec ::= pair(real:Real;complex:Real)
     preds 
          __ >= __, __ > __: Real * Real;

	   ops
	   __ + __:Real * Real -> Real;
	   __ * __:Real * Real -> Real;
	  - __: Real -> Real;
	  ti __: Real -> Real;
     	  0:Real;
	  1:Real;
	  field_norm __:Real -> Real;
	  __ vpl __:Vec * Vec -> Vec;
	  __ vti __:Real * Vec -> Vec;
	  vmi __:Vec -> Vec;
	  vec_norm __:Vec->Real;
	  vzero:Vec
	  %%% introducing 2-d vectors
	  basis_real:Vec;
	  basis_complex:Vec

 forall x,y,z,v:Real;
	a,b,c,d:Vec
	    . (exists t:Real.(x+y)=t)
     	    . x+0=x			
     	    . x+y=y+x
	    . x+(y+z) = (x+y)+z
	    . x + (-x) = 0
	    . ((not (x=0)) /\ (not (y=0))) => (exists t:Real.x*y=t)
	    . ((not (x=0)) /\ (not (y=0))) => x*y = y*x
	    . ((not (x=0)) /\ (not (y=0)) /\ (not (z=0))) => (x*y)*z=x*(y*z)
	    . (not (x=0)) => x*(ti x) = 1 
	    . ((not (x=0)) /\ (not (y=0)) /\ (not (z=0))) => x*(y+z) = (x*y)+(x*z)
	    . ((x >=y) /\ (z >= v)) => (x+z) >= (y+v)
	    . (x>0) /\ (y>0) => (x*y)>0
	    . (exists e:Vec. (a vpl b)=e)
	    . (a vpl vzero) = a
	    . (a vpl b) = (b vpl a)
	    . (a vpl (c vpl d)) = ((a vpl c) vpl d)
	    . (a vpl (vmi a)) = vzero
	    . (x vti (a vpl b)) = (x vti a) vpl (x vti b)
	    . ((x+y) vti a) = (x vti a) vpl (y vti a)
	    . (x vti (y vti a)) = (x * y) vti a
	    . (1 vti a) = a
	    . (vec_norm a) >= 0
	    . (vec_norm a >= 0 <=> (not (a = vzero)))
	    . (vec_norm (x vti a)) = (field_norm x)*(vec_norm a)
	    . (vec_norm (a vpl b)) = (vec_norm a) + (vec_norm b)
	      %%% forcing linear independence
	    . (((x vti basis_real) vpl (y vti basis_complex)) = vzero) <=> (x = 0) /\ (y = 0)
	    . (exists s,t:Real. a = ((s vti basis_real) vpl (t vti basis_complex)))
end

spec Gen = 
     sort Generic
     ops
     __ plus __:Generic * Generic -> Generic;
     zero:Generic;
     minus __:Generic -> Generic
	   
	forall x,y:Generic
     	       . x plus  zero=x			
     	       . x plus y=y plus x
	       . x plus (minus x) = zero
end


view I1: Gen to Field = 
		__ plus __ |-> __ + __, zero |-> 0, minus __ |-> - __

view I2: Gen to VectorSpace = 
	       __ plus __ |-> __ vpl __,zero |-> vzero, minus __ |-> vmi __


spec Colimit =
  combine I1,I2 
end


spec Complex_Field = 
     sort Real
     free type Complex ::= pair(real:Real,complex:Real)
     preds 
	   __ >= __, __ > __:Real * Real;
	   __ gte __, __ gt __: Complex * Complex;
     ops
     __ + __: Real * Real -> Real;
     __ * __: Real * Real -> Real;
     - __: Real -> Real;
     ti __: Real -> Real;
     0: Real;
     1: Real;
     field_norm __:Real -> Real;
     __ cpl __:Complex * Complex -> Complex;
     __ cti __:Real * Complex -> Complex;
     cmi __:Complex -> Complex;
     complex_norm __:Complex -> Real;
     complex_zero:Complex;
     %%% introducing 2-d vectors
     basis_real:Complex;
     basis_complex:Complex;
     __ prod __: Complex * Complex -> Complex;
     times_inv __: Complex -> Complex;
     norm __: Complex -> Real

     forall x,y,z,v:Real;
	    a,b,c,d:Complex
	    . (exists t:Real.(x+y) = t)
	    . x+0=x			
     	    . x+y=y+x
	    . x+(y+z) = (x+y)+z
	    . x + (-x) = 0
	    . ((not (x=0)) /\ (not (y=0))) => (exists t:Real.x*y=t)
	    . ((not (x=0)) /\ (not (y=0))) => x*y = y*x
	    . ((not (x=0)) /\ (not (y=0)) /\ (not (z=0))) => (x*y)*z=x*(y*z)
	    . (not (x=0)) => x*(ti x) = 1 
	    . ((not (x=0)) /\ (not (y=0)) /\ (not (z=0))) => x*(y+z) = (x*y)+(x*z)
	    . ((x >= y) /\ (z >= v)) => (x+z) >= (y+v)
	    . (x>0) /\ (y>0) => (x*y)>0
	    . (exists e:Complex. (a cpl b)=e)
	    . (a cpl complex_zero) = a
	    . (a cpl b) = (b cpl a)
	    . (a cpl (c cpl d)) = ((a cpl c) cpl d)
	    . (a cpl (cmi a)) = complex_zero
	    . (x cti (a cpl b)) = (x cti a) cpl (x cti b)
	    . ((x+y) cti a) = (x cti a) cpl (y cti a)
	    . (x cti (y cti a)) = (x * y) cti a
	    . basis_real = pair(1,0)
	    . basis_complex = pair(0,1)
	    . (pair (x,y)) cpl (pair (z,v)) = (pair((x+z),(y+v)))
	    . (pair(x,y) prod pair(z,v)) = pair(((x*z)+(-(y*v))),((x*v)+(y*z)))
	    . times_inv a = a
	    . norm a = 0
end

%[view I3: Colimit to Complex_Field =]%
%[     1 |-> basis_real,]%
%[     __ * __ |-> __ prod __]%

    %[ __ prod __ |-> __ * __,]%
    %[ __ + __ |->  __ + __,]%
    %[ __ cpl __ |-> __ vpl __,]%
    %[ __ cti __ |-> __ vti __,]%
    %[ basis_complex |-> basis_complex,]%
    %[ basis_real |-> basis_real,]%
    %[ times_inv __ |-> ti,]%
    %[ norm __ |-> vec_norm,]%
    %[ cmi __ |-> vmi __,]%
    %[ zero |-> vzero,]%
    %[ __ gt __ |-> __ > __,]%
    %[__ gte __ |-> __ >= __]%

			  
