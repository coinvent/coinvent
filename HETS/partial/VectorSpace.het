logic Isabelle

typedecl Real

datatype Vec = X_pair "Real" "Real" ("pair''/'(_,/ _')" [3,3] 999)

consts
X0 :: "Real" ("0''")
X1 :: "Real" ("1''")
XMinus__X :: "Real => Real" ("(-''/ _)" [56] 56)
X__XGtXEq__X :: "Real => Real => bool" ("(_/ >=''/ _)" [44,44] 42)
X__XGt__X :: "Real => Real => bool" ("(_/ >''/ _)" [44,44] 42)
X__XPlus__X :: "Real => Real => Real" ("(_/ +''/ _)" [54,54] 52)
X__Xx__X :: "Real => Real => Real" ("(_/ *''/ _)" [54,54] 52)
X__vpl__X :: "Vec => Vec => Vec" ("(_/ vpl/ _)" [54,54] 52)
X__vti__X :: "Real => Vec => Vec" ("(_/ vti/ _)" [54,54] 52)
X_basis_complex :: "Vec" ("basis'_complex")
X_basis_real :: "Vec" ("basis'_real")
X_complex :: "Vec => Real" ("complex/'(_')" [3] 999)
X_real :: "Vec => Real" ("real/'(_')" [3] 999)
field_norm__X :: "Real => Real" ("(field'_norm/ _)" [56] 56)
sq__X :: "Real => Real" ("(sq/ _)" [56] 56)
sqrt__X :: "Real => Real partial" ("(sqrt/ _)" [56] 56)
times_inv__X :: "Real => Real partial" ("(times'_inv/ _)" [56] 56)
vec_norm__X :: "Vec => Real" ("(vec'_norm/ _)" [56] 56)
vmi__X :: "Vec => Vec" ("(vmi/ _)" [56] 56)
vzero :: "Vec"

ga_selector_real [rule_format] :
"ALL (XX1 :: Real). ALL (XX2 :: Real). real(pair'(XX1, XX2)) = XX1"

ga_selector_complex [rule_format] :
"ALL (XX1 :: Real).
 ALL (XX2 :: Real). complex(pair'(XX1, XX2)) = XX2"

ga_injective_pair [rule_format] :
"ALL (XX1 :: Real).
 ALL (XX2 :: Real).
 ALL (Y1 :: Real).
 ALL (Y2 :: Real).
 pair'(XX1, XX2) = pair'(Y1, Y2) = (XX1 = Y1 & XX2 = Y2)"

Ax5 [rule_format] : "ALL (x :: Real). x +' 0' = x"

Ax6 [rule_format] :
"ALL (x :: Real). ALL (y :: Real). x +' y = y +' x"

Ax7 [rule_format] :
"ALL (x :: Real).
 ALL (y :: Real). ALL (z :: Real). x +' (y +' z) = (x +' y) +' z"

Ax8 [rule_format] : "ALL (x :: Real). x +' -' x = 0'"

Ax9 [rule_format] :
"ALL (x :: Real). ALL (y :: Real). x *' y = y *' x"

Ax10 [rule_format] :
"ALL (x :: Real).
 ALL (y :: Real). ALL (z :: Real). (x *' y) *' z = x *' (y *' z)"

Ax11 [rule_format] : "ALL (x :: Real). x *' 1' = x"

Ax12 [rule_format] :
"ALL (x :: Real).
 ~ x = 0' -->
 (case times_inv x of
  None => undefinedOp |
  Some Xc0 => makePartial (x *' Xc0)) =
 makePartial 1'"

Ax13 [rule_format] :
"ALL (x :: Real).
 ALL (y :: Real).
 ALL (z :: Real). x *' (y +' z) = (x *' y) +' (x *' z)"

Ax14 [rule_format] :
"ALL (x :: Real).
 ALL (y :: Real).
 ALL (z :: Real).
 ALL (v :: Real). x >=' y & z >=' v --> x +' z >=' y +' v"

Ax15 [rule_format] :
"ALL (x :: Real).
 ALL (y :: Real). x >' 0' & y >' 0' --> x *' y >' 0'"

Ax16 [rule_format] : "vzero = pair'(0', 0')"

Ax17 [rule_format] :
"ALL (x :: Real).
 ALL (y :: Real).
 ALL (z :: Real).
 ALL (v :: Real).
 pair'(x, y) vpl pair'(z, v) = pair'(x +' z, y +' v)"

Ax18 [rule_format] :
"ALL (x :: Real).
 ALL (y :: Real). vmi pair'(x, y) = pair'(-' x, -' y)"

Ax19 [rule_format] :
"ALL (x :: Real).
 ALL (a :: Vec).
 ALL (b :: Vec). x vti (a vpl b) = (x vti a) vpl (x vti b)"

Ax20 [rule_format] :
"ALL (x :: Real).
 ALL (y :: Real).
 ALL (a :: Vec). (x +' y) vti a = (x vti a) vpl (y vti a)"

Ax21 [rule_format] :
"ALL (x :: Real).
 ALL (y :: Real). ALL (a :: Vec). x vti (y vti a) = (x *' y) vti a"

Ax22 [rule_format] : "ALL (a :: Vec). 1' vti a = a"

Ax23 [rule_format] : "ALL (a :: Vec). vec_norm a >=' 0'"

Ax24 [rule_format] :
"ALL (a :: Vec). (vec_norm a >' 0') = (~ a = vzero)"

Ax25 [rule_format] :
"ALL (x :: Real).
 ALL (a :: Vec). vec_norm (x vti a) = field_norm x *' vec_norm a"

Ax26 [rule_format] :
"ALL (a :: Vec).
 ALL (b :: Vec). vec_norm (a vpl b) = vec_norm a +' vec_norm b"

Ax27 [rule_format] :
"ALL (x :: Real).
 ALL (y :: Real).
 (x vti basis_real) vpl (y vti basis_complex) = vzero =
 (x = 0' & y = 0')"

Ax28 [rule_format] :
"ALL (a :: Vec).
 EX (s :: Real).
 EX (t :: Real). a = (s vti basis_real) vpl (t vti basis_complex)"

theorem Ax1 : "ALL (x :: Vec). x vpl vzero = x"
oops

theorem Ax2 : "ALL (x :: Vec). ALL (y :: Vec). x vpl y = y vpl x"
oops

theorem Ax3 :
"ALL (x :: Vec).
 ALL (y :: Vec). ALL (z :: Vec). x vpl (y vpl z) = (x vpl y) vpl z"
oops

theorem Ax4 : "ALL (x :: Vec). x vpl vmi x = vzero"
oops
