logic CASL

%%% ordered field

spec Field =
     sort Real
     preds 
          __ >= __, __ > __: Real * Real;

	  ops
	  __ + __:Real * Real -> Real;
	  __ * __:Real * Real -> Real;
	  - __: Real -> Real;
	  times_inv __: Real ->? Real;
     	  0:Real;
	  1:Real;

		     
     forall x,y,z,v:Real
	    . x+0=x	%f_plus_ident%		
     	    . x+y=y+x   %f_com_plus%
	    . x+(y+z) = (x+y)+z  %f_assoc_plus%
	    . x + (-x) = 0    %f_plus_inv%
	    . x*y = y*x  %f_com_times%
	    . (x*y)*z=x*(y*z) %f_assoc_times%
	    . (not (x=0)) => x*(times_inv x) = 1 %f_times_inv%
	    . (not (x=0)) => x*1 = x %f_times_ident$
 	    . x*(y+z) = (x*y)+(x*z) %f_dist_times%
	    . ((x >=y) /\ (z >= v)) => (x+z) >= (y+v) %f_order_+%
	    . (x>0) /\ (y>0) => (x*y)>0  %f_order_*%
 end
				    
	     	   

%%%% This is a vector space with a norm

spec VectorSpace = 
     sort Real
     free type Vec ::= pair(real:Real;complex:Real)
     preds 
          __ >= __, __ > __: Real * Real;

	   ops
	   __ + __:Real * Real -> Real;
	   __ * __:Real * Real -> Real;
	  - __: Real -> Real;
	  times_inv __: Real ->? Real;
     	  0:Real;
	  1:Real;
	  field_norm __:Real -> Real;
	  __ vpl __:Vec * Vec -> Vec;
	  __ vti __:Real * Vec -> Vec;
	  vmi __:Vec -> Vec;
	  vec_norm __:Vec->Real;
	  vzero:Vec
	  %%% introducing 2-d vectors
	  basis_real:Vec;
	  basis_complex:Vec;
	  

 forall x,y,z,v:Real;
	a,b,c,d:Vec
     	    . x+0=x  %vf_plus_ident%			
     	    . x+y=y+x %vf_com_plus%
	    . x+(y+z) = (x+y)+z %vf_assoc_plus%
	    . x + (-x) = 0 %vf_plus_inv%
	    . x*y = y*x %vf_times_ident%
	    . (x*y)*z=x*(y*z) %vf_assoc_times%
	    . x*1 = x %vf_times_ident%
	    . (not (x=0)) => x*(times_inv x) = 1 %vf_times_inv% 
	    . x*(y+z) = (x*y)+(x*z) %vf_dist%
	    . ((x >=y) /\ (z >= v)) => (x+z) >= (y+v) %vf_order_+%
	    . (x>0) /\ (y>0) => (x*y)>0 %vf_order_*%
	    . vzero = pair (0,0) %vzero_def%
	    . (pair(x,y) vpl pair (z,v)) = pair(x+z,y+v) %vplus_def%
	    . vmi pair(x,y) = pair(-x,-y) %vminus_def%
	    . (x vti (a vpl b)) = (x vti a) vpl (x vti b) %scalar_vecplus%
	    . ((x+y) vti a) = (x vti a) vpl (y vti a) %scalarplus_vec%
	    . (x vti (y vti a)) = (x * y) vti a %scalar_times_vec%
	    . (1 vti a) = a %scalar_vec_times_ident%
	    . (vec_norm a) >= 0 %vec_norm_non_neg%
	    . (vec_norm a > 0 <=> (not (a = vzero))) %vec_norm_zero%
	    . (vec_norm (x vti a)) = (field_norm x)*(vec_norm a) %norms%
	    . ((vec_norm a) + (vec_norm b)) >= vec_norm (a vpl b) %norm_plus%
	      %%% forcing linear independence
	    . (((x vti basis_real) vpl (y vti basis_complex)) = vzero) <=> (x = 0) /\ (y = 0) %li1%
	    . (exists s,t:Real. a = ((s vti basis_real) vpl (t vti basis_complex))) %comp_vec%
end

spec Gen = 
     sort Generic
     ops
     __ plus __:Generic * Generic -> Generic;
     zero:Generic;
     minus __:Generic -> Generic
	   
	forall x,y,z:Generic
     	       . x plus  zero=x	 %gen_plus_ident%		
     	       . x plus y=y plus x %gen_com_plus%
	       . x plus (y plus z) = (x plus y) plus z %gen_assoc_plus%
	       . x plus (minus x) = zero %gen_plus_inv%
end


view I1: Gen to Field = 
		__ plus __ |-> __ + __, zero |-> 0, minus __ |-> - __

view I2: Gen to VectorSpace = 
	       __ plus __ |-> __ vpl __,zero |-> vzero, minus __ |-> vmi __


spec Colimit =
     combine I1,I2  
	     with 
	     gn_n2 |-> gt, gn_n4:Real*Real |-> gte,
             gn_n4:Real |-> one,
             gn_n6 |-> co_times:Real * Real -> Real,
             gn_times_inv18 __ |-> co_times_inv __
end

